# from future import __annotations__
__all__ = ['SymmFieldMod']

import numpy as np

from qtm.gspace import GSpace
from qtm.crystal import Crystal
from qtm.containers import FieldGType

from qtm.config import qtmconfig

from qtm.msg_format import *
from qtm.constants import TPIJ

ROUND_PREC: int = 6


class SymmFieldMod:

    def __init__(self, crystal: Crystal, gspc: GSpace):
        if not isinstance(crystal, Crystal):
            raise TypeError(
                type_mismatch_msg('crystal', crystal, Crystal)
            )
        if not isinstance(gspc, GSpace):
            raise TypeError(
                type_mismatch_msg('gspc', gspc, GSpace)
            )

        if gspc.is_dist:
            gspc = gspc.gspc_glob

        self.gspc = gspc
        size_g = self.gspc.size_g
        grid_shape = self.gspc.grid_shape
        n1, n2, n3 = grid_shape
        g_cryst = self.gspc.g_cryst
        g_norm2 = np.around(gspc.g_norm2, ROUND_PREC)

        crystal_symm = crystal.symm
        crystal_symm.filter_frac_trans(grid_shape)
        recilat_rot = np.asarray(crystal_symm.recilat_rot, like=g_cryst)
        reallat_trans = np.asarray(crystal_symm.reallat_trans, like=g_cryst)

        # Sorting G-vectors such that they are grouped by their lengths, within
        # which they are sorted by their corresponding 'idxgrid'
        i1, i2, i3 = g_cryst
        idxsort = np.lexsort((i3 + n3 * (i3 < 0),
                              i2 + n2 * (i2 < 0),
                              i1 + n1 * (i1 < 0),
                              g_norm2))

        # Splitting the set of G-vectors into groups with same lengths (shells)
        _, isplit = np.unique(g_norm2[idxsort], return_index=True)

        shells_ig = []
        shells_phase = []
        for ig in np.split(idxsort, isplit)[1:]:
            # Rotating all G-vectors in shell with all symmetries
            g_cryst_shell = g_cryst[:, ig]
            g_cryst_rot = np.tensordot(recilat_rot, g_cryst_shell, axes=1)

            # Computing the idxgrid of all generated G-vectors
            i1, i2, i3 = g_cryst_rot.transpose((1, 0, 2))
            idxgrid_rot = n2 * n3 * (i1 + n1 * (i1 < 0)) \
                + n3 * (i2 + n2 * (i2 < 0)) \
                + (i3 + n3 * (i3 < 0))

            # Constructing a subset of G-vectors that will yield all G-vectors
            # in shell using symmetry operations.
            # Note that since the symmetry operations form a group, they
            # generate the same (unordered) set of G-vector when applied to any
            # of the vectors in the set.
            # Step 1: For each subset of G-vectors generated by rotating a
            # single G-vector, we choose one among them in a way independent
            # of ordering within the subset.
            # Step 2: Then we take the unique vectors among them. This new set
            # is enough to generate all the G-vectors in shell
            _, idx_red = np.unique(np.amin(idxgrid_rot, axis=0), return_index=True)

            shells_ig.append(ig[np.searchsorted(
                idxgrid_rot[0], idxgrid_rot[:, idx_red]
            )])
            shells_phase.append(np.exp(TPIJ * np.sum(
                reallat_trans[..., np.newaxis]
                * g_cryst_rot[:, :, idx_red], axis=1
            )))

        self.shells_ig = np.concatenate(shells_ig, axis=1)

        self.shells_phase = np.concatenate(shells_phase, axis=1)

        g_phase = np.zeros(size_g, dtype='c16', like=g_cryst)
        g_count = np.zeros(size_g, dtype='i8', like=g_cryst)
        for ig, phase in zip(self.shells_ig, self.shells_phase):
            g_phase[ig] += phase
            g_count[ig] += 1
        self.g_phaseconj = np.conj(g_phase) / g_count

    def _symmetrize(self, arr_g: np.ndarray):
        out = np.empty_like(arr_g, dtype='c16')
        out[..., self.shells_ig] = np.mean(
            arr_g[..., self.shells_ig] * self.shells_phase,
            axis=-2, keepdims=True
        )
        out *= self.g_phaseconj
        return out

    def symmetrize(self, field_g: FieldGType):
        print('at symmetrize')
        if not isinstance(field_g, FieldGType):
            raise TypeError(type_mismatch_msg('field_g', field_g, FieldGType))

        is_dist = False
        if qtmconfig.mpi4py_installed:
            from qtm.mpi.containers import DistBufferType
            if isinstance(field_g, DistBufferType):
                is_dist = True
        if is_dist:
            field_g_ = field_g.allgather()
        else:
            field_g_ = field_g.copy()

        if field_g_.gspc is not self.gspc:
            raise ValueError(
                obj_mismatch_msg('field_g.gspc', field_g_.gspc,
                                 'SymmetrizeMod.gspc', self.gspc)
            )

        for f in field_g_.reshape(-1):
            f.data[:] = self._symmetrize(f.data)

        if not is_dist:
            return field_g_
        out = type(field_g).empty(field_g.shape)
        out.data[:] = field_g_.data[..., out.gspc.ig_loc]
        return out

