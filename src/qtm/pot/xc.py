__all__ = ['get_libxc_func', 'check_libxc_func', 'compute']
import numpy as np

from pylibxc import LibXCFunctional
from pylibxc.util import xc_available_functional_names
import pylibxc.flags as xc_flags

from qtm.crystal import Crystal
from qtm.containers import FieldG, FieldR
from qtm.logger import qtmlogger
from .utils import check_rho, fieldg_grad, fieldg_div


def get_libxc_func(crystal: Crystal) -> tuple[str, str]:
    libxc_func = None
    for typ in crystal.l_atoms:
        ppdata = typ.ppdata
        if ppdata.libxc_func is None:
            qtmlogger.warn(
                "could not find the correct libxc functional names for "
                f"species '{typ.label}' (Pseudopotential: '{ppdata.filename}').\n"
            )
            continue
        if libxc_func is None:
            libxc_func = ppdata.libxc_func
        elif ppdata.libxc_func != libxc_func:
            raise ValueError(
                "XC functionals is not identical across all species. "
                "Manually specify the functionals using libxc functional names."
            )

    return libxc_func


def check_libxc_func(libxc_func):
    l_avail_funcname = xc_available_functional_names()
    for funcname in libxc_func:
        if funcname not in l_avail_funcname:
            raise ValueError(
                f"XC Functional '{funcname}' is not avaialable in libxc."
            )


def _get_sigma(rhoaux: FieldG) -> np.ndarray:
    r"""Generates the contracted gradient 'sigma' of input electron density.
    Required by libxc for computing potentials for GGA Functionals.

    Parameters
    ----------
    rhoaux : GField
        Input Electron Density

    Returns
    -------
    sigma_r : np.ndarray
        'sigma' array to be passed to `pylibxc.LibXCFunctional` for evaluating
        GGA Functional

    Notes
    -----
    Refer to the `libxc manual`_ for further details

    .. _libxc manual: https://www.tddft.org/programs/libxc/manual/libxc-5.1.x/
    """
    grho = rhoaux.gspc
    numspin = rhoaux.shape[0]
    grad_rhoaux = fieldg_grad(rhoaux).to_fieldr()

    sigma_r = np.empty((2*numspin - 1, grho.size_r), dtype='f8')
    sigma_r[0] = np.sum(grad_rhoaux[0].r * grad_rhoaux[0].r, axis=0).real
    if numspin == 2:
        sigma_r[1] = np.sum(grad_rhoaux[0].r * grad_rhoaux[1].r, axis=0).real
        sigma_r[2] = np.sum(grad_rhoaux[1].r * grad_rhoaux[1].r, axis=0).real

    return np.copy(sigma_r.T, order='C')


@qtmlogger.time('xc_compute')
def compute(rho: FieldG, rhocore: FieldG,
            exch_name: str, corr_name: str) -> tuple[FieldR, float]:
    """Computes the XC Potential generated by input charge density.

    The XC functional is specified by ``exch_name`` and ``corr_name``. The core
    charge density ``rhocore`` is required for Non-local Core correction.

    Parameters
    ----------
    rho : GField
        Input electron density
    rhocore : GField
        Core electron density. Generated from pseudopotential data
    exch_name : str
        Name of Exchange Functional
    corr_name : str
        Name of Correlation Functional

    Returns
    -------
    v_xc : GField
        XC Potential
    en_xc : float
        Contribution of XC Potential to total energy (per unit cell)
    """
    check_rho(rho)
    check_rho(rhocore)
    if rho.gspc != rhocore.gspc:
        raise ValueError("'gspc' of 'rho' and 'rho_core' must match.")

    grho = rho.gspc
    numspin = rho.shape[0]
    print(rhocore)
    print(numspin)
    rhoaux = rho + (1. / numspin) * rhocore

    exch_func = LibXCFunctional(exch_name, numspin)
    corr_func = LibXCFunctional(corr_name, numspin)

    need_grad = sum(
        True if xcfunc.get_family() in
        [xc_flags.XC_FAMILY_GGA, xc_flags.XC_FAMILY_MGGA]
        else False
        for xcfunc in [exch_func, corr_func]
    )
    grad_rho = None
    if need_grad:
        grad_rho = fieldg_grad(rho).to_fieldr()

    # for xcfunc in [exch_func, corr_func]:
    #     if xcfunc.get_family() == xc_flags.XC_FAMILY_LDA:
    #         xcfunc.set_dens_threshold(config.libxc_thr_lda_rho)
    #     elif xcfunc.get_family() == xc_flags.XC_FAMILY_GGA:
    #         xcfunc.set_dens_threshold(config.libxc_thr_gga_rho)
    #         xcfunc.set_sigma_threshold(config.libxc_thr_gga_sig)

    rho = rho.to_fieldr()
    xc_inp = {"rho": np.copy(np.abs(rho.r[:]).T, "C")}
    if need_grad:
        xc_inp["sigma"] = _get_sigma(rhoaux)

    v_xc = FieldR.zeros(grho, numspin)
    en_xc = 0
    print('b4 loop', v_xc.r.shape)
    for xcfunc in [exch_func, corr_func]:
        xcfunc_out = xcfunc.compute(xc_inp)
        zk_r = xcfunc_out['zk'].T
        v_r = np.reshape(xcfunc_out['vrho'].T, (numspin, -1))
        v_xc.r[:] += v_r
        en_xc += np.sum(rho * zk_r) * grho.reallat_dv

        if need_grad:
            vsig_r = FieldR(
                grho, xcfunc_out['vsigma'].T.reshape((-1, grho.size_r)).astype('c16')
            )
            # h_r = np.empty((numspin, 3, grho.size_r), dtype='c16')
            h_r = FieldR.empty(grho, (numspin, 3))
            if numspin == 1:
                h_r[0] = 2*vsig_r[0]*grad_rho[0].r
            else:
                h_r[0] = 2*vsig_r[0]*grad_rho[0].r + vsig_r[1]*grad_rho[1].r
                h_r[1] = 2*vsig_r[2]*grad_rho[1].r + vsig_r[1]*grad_rho[0].r
            div_h = fieldg_div(h_r.to_fieldg()).to_fieldr()
            print(div_h.shape, div_h.r.shape)
            v_xc -= div_h

    return v_xc, en_xc.real
