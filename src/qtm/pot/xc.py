from __future__ import annotations
__all__ = ['get_libxc_func', 'check_libxc_func', 'compute']
import numpy as np

from pylibxc import LibXCFunctional
from pylibxc.util import xc_available_functional_names
import pylibxc.flags as xc_flags

from qtm.crystal import Crystal
from qtm.containers import FieldGType, FieldRType, get_FieldR
from qtm.logger import qtmlogger
from .utils import check_rho, fieldg_grad, fieldg_div

from qtm.config import CUPY_INSTALLED

# Thresholds
lda_rho_thr = 1E-10
gga_rho_thr = 1E-6
gga_sigma_thr = 1E-10


def set_threshold(l_xc_func):
    for xc_func in l_xc_func:
        if xc_func.get_family() == xc_flags.XC_FAMILY_LDA:
            xc_func.set_dens_threshold(lda_rho_thr)
        elif xc_func.get_family() == xc_flags.XC_FAMILY_GGA:
            xc_func.set_dens_threshold(gga_rho_thr)
            xc_func.set_sigma_threshold(gga_sigma_thr)
    return l_xc_func


def get_libxc_func(crystal: Crystal) -> tuple[str, str]:
    libxc_func = None
    for typ in crystal.l_atoms:
        ppdata = typ.ppdata
        if ppdata.libxc_func is None:
            qtmlogger.warn(
                "could not find the correct libxc functional names for "
                f"species '{typ.label}' (Pseudopotential: '{ppdata.filename}').\n"
            )
            continue
        if libxc_func is None:
            libxc_func = ppdata.libxc_func
        elif ppdata.libxc_func != libxc_func:
            raise ValueError(
                "XC functionals is not identical across all species. "
                "Manually specify the functionals using libxc functional names."
            )

    return libxc_func


def check_libxc_func(libxc_func):
    l_avail_funcname = xc_available_functional_names()
    for funcname in libxc_func:
        if funcname not in l_avail_funcname:
            raise ValueError(
                f"XC Functional '{funcname}' is not avaialable in libxc."
            )


def _get_sigma(rhoaux: FieldGType) -> FieldRType:
    r"""Generates the contracted gradient 'sigma' of input electron density.
    Required by libxc for computing potentials for GGA Functionals.

    Parameters
    ----------
    rhoaux : GField
        Input Electron Density

    Returns
    -------
    sigma_r : FieldRType
        contains 'sigma' array to be passed to `pylibxc.LibXCFunctional`
        for evaluating GGA Functional

    Notes
    -----
    Refer to the `libxc manual`_ for further details

    .. _libxc manual: https://www.tddft.org/programs/libxc/manual/libxc-5.1.x/
    """
    grho = rhoaux.gspc
    numspin = rhoaux.shape[0]
    grad_rhoaux = fieldg_grad(rhoaux).to_r()

    RField = type(grad_rhoaux)
    sigma = RField.empty(2*numspin - 1, dtype='f8')
    sigma[0] = np.sum(grad_rhoaux[0] * grad_rhoaux[0], axis=0).real
    if numspin == 2:
        sigma[1] = np.sum(grad_rhoaux[0] * grad_rhoaux[1], axis=0).real
        sigma[2] = np.sum(grad_rhoaux[1] * grad_rhoaux[1], axis=0).real
    return sigma


@qtmlogger.time('xc_compute')
def compute(rho: FieldGType, rhocore: FieldGType,
            exch_name: str, corr_name: str) -> tuple[FieldRType, float]:
    """Computes the XC Potential generated by input charge density.

    The XC functional is specified by ``exch_name`` and ``corr_name``. The core
    charge density ``rhocore`` is required for Non-local Core correction.

    Parameters
    ----------
    rho : FieldG
        Input electron density
    rhocore : FieldG
        Core electron density. Generated from pseudopotential data
    exch_name : str
        Name of Exchange Functional
    corr_name : str
        Name of Correlation Functional

    Returns
    -------
    v_xc : GField
        XC Potential
    en_xc : float
        Contribution of XC Potential to total energy (per unit cell)
    """
    check_rho(rho)
    check_rho(rhocore)
    if rho.gspc != rhocore.gspc:
        raise ValueError("'gspc' of 'rho' and 'rho_core' must match.")

    grho = rho.gspc
    numspin = rho.shape[0]
    rhoaux = rho + (1. / numspin) * rhocore

    exch_func = LibXCFunctional(exch_name, numspin)
    corr_func = LibXCFunctional(corr_name, numspin)
    
    # Set thresholds
    exch_func, corr_func = tuple(set_threshold([exch_func, corr_func]))
    
    need_grad = sum(
        True if xcfunc.get_family() in
        [xc_flags.XC_FAMILY_GGA, xc_flags.XC_FAMILY_MGGA]
        else False
        for xcfunc in [exch_func, corr_func]
    )

    rho_r = rho.to_r()
    xc_inp = {"rho": np.copy(np.abs(rho_r.data).T, "C")}
    grad_rho_r = None
    if need_grad:
        grad_rho_r = fieldg_grad(rho).to_r()
        xc_inp["sigma"] = np.copy(_get_sigma(rhoaux).data.T, 'C')

    FieldR: type[FieldRType] = type(rho_r)

    v_xc = FieldR.zeros(numspin)
    en_xc = 0

    if CUPY_INSTALLED:
        import cupy as cp
        for key, val in xc_inp.items():
            xc_inp[key] = val.get() if isinstance(val, cp.ndarray) else val

    for xcfunc in [exch_func, corr_func]:
        xcfunc_out = xcfunc.compute(xc_inp)
        for key in xcfunc_out:
            xcfunc_out[key] = np.asarray(xcfunc_out[key], like=grho.g_cryst)
        zk_r = FieldR.from_array(xcfunc_out['zk'].T)
        v_r = FieldR.from_array(xcfunc_out['vrho'].T.reshape((numspin, -1)))
        v_xc += v_r
        en_xc += sum((rho_r * zk_r)).integrate_unitcell()

        if need_grad:
            vsig_r = FieldR.from_array(
                xcfunc_out['vsigma'].T.reshape((-1, grho.size_r))
            )
            # h_r = np.empty((numspin, 3, grho.size_r), dtype='c16')
            h_r = FieldR.empty((numspin, 3))
            if numspin == 1:
                h_r[0] = 2 * vsig_r[0] * grad_rho_r[0]
            else:
                h_r[0] = 2*vsig_r[0] * grad_rho_r[0] + vsig_r[1] * grad_rho_r[1]
                h_r[1] = 2*vsig_r[2] * grad_rho_r[1] + vsig_r[1] * grad_rho_r[0]
            div_h = fieldg_div(h_r.to_g()).to_r()

            v_xc -= div_h

    return v_xc, en_xc.real
