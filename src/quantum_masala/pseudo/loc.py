__all__ = ["loc_generate_pot_rhocore", "loc_generate_rhoatomic"]

import numpy as np
from scipy.special import erf, spherical_jn

from quantum_masala import pw_logger
from quantum_masala.core import AtomBasis, GSpace, GField
from .upf import UPFv2Data

EPS6 = 1E-6


def _simpson(f_r: np.ndarray, r_ab: np.ndarray):
    f_times_dr = f_r * r_ab
    # NOTE: Number of radial points specified in UPF File is expected to be odd. Will fail otherwise
    f_times_dr[:] *= 1./3
    f_times_dr[..., 1:-1:2] *= 4
    f_times_dr[..., 2:-1:2] *= 2
    return np.sum(f_times_dr, axis=-1)


def _sph2pw(r: np.ndarray, r_ab: np.ndarray, f_times_r2: np.ndarray,
            g: np.ndarray):
    numg = g.shape[0]
    f_g = np.empty((*f_times_r2.shape[:-1], numg), dtype='c16')
    numr = r.shape[0]

    r_ab = r_ab.copy()
    r_ab *= 1./3
    r_ab[1:-1:2] *= 4
    r_ab[2:-1:2] *= 2
    f_g[:] = spherical_jn(0, g * r[0]) * f_times_r2[..., 0] * r_ab[0]

    g = g.reshape(-1, 1)
    f_times_r2 = np.expand_dims(f_times_r2, axis=-2)
    for idxr in range(numr):
        f_g[:] += np.sum(spherical_jn(0, g * r[idxr])
                         * f_times_r2[..., idxr] * r_ab[idxr],
                         axis=-1)
    return f_g


@pw_logger.time('rho_generate_atomic')
def loc_generate_rhoatomic(sp: AtomBasis, grho: GSpace) -> GField:
    """Computes the electron density constructed by superposing atomic charges
    of given atomic species in crystal.

    Parameters
    ----------
    sp
        Repesents an atomic species (and corresponding atoms)
        present in the crystal.
    grho
        G-Space of the potential/charge density

    Returns
    -------
    v_ion
        Local part of the pseudopotenital
    rho_core
        Charge density of core electrons
    """
    if sp.ppdata is None:
        raise ValueError("'sp.ppdata' must not be None.")
    if not isinstance(sp.ppdata, UPFv2Data):
        raise NotImplementedError("only 'UPFv2Data' supported")

    upfdata: UPFv2Data = sp.ppdata
    # Radial Mesh specified in Pseudopotential Data
    r = upfdata.r
    r_ab = upfdata.r_ab

    # Setting constants and aliases
    cellvol = grho.reallat_cellvol
    _4pibv = 4 * np.pi / cellvol
    _1bv = 1 / cellvol

    g_cryst = grho.cryst
    g_norm2 = grho.norm2
    g_norm = np.sqrt(g_norm2)

    struct_fac = np.sum(
        np.exp((-2 * np.pi * 1j) * (sp.cryst.T @ g_cryst)), axis=0
    )

    rhoatom = upfdata.rhoatom

    rho = GField.empty(grho, 1)

    f_times_r2 = np.empty((1, len(r)), dtype='f8')
    f_times_r2[0] = _1bv * rhoatom

    f_g = _sph2pw(r, r_ab, f_times_r2, g_norm[1:])
    rho.g[0, 0] = _1bv * _simpson(rhoatom, r_ab)
    rho.g[0, 1:] = f_g

    N = np.prod(grho.grid_shape)
    rho.g[:] *= N * struct_fac

    return rho


@pw_logger.time('loc_generate')
def loc_generate_pot_rhocore(sp: AtomBasis, grho: GSpace) -> (GField, GField):
    """Computes the local part of pseudopotential and core electron density
    (for non-linear core correction in XC calculation) generated by given
    atomic species in crystal.

    Parameters
    ----------
    sp
        Atomic species (and corresponding atoms) in the crystal.
    grho
        G-Space of the potential/charge density

    Returns
    -------
    v_ion
        Local part of the pseudopotenital
    rho_core
        Charge density of core electrons
    """
    if sp.ppdata is None:
        raise ValueError("'sp.ppdata' must not be None.")
    if not isinstance(sp.ppdata, UPFv2Data):
        raise NotImplementedError("only 'UPFv2Data' supported")

    upfdata: UPFv2Data = sp.ppdata
    # Radial Mesh specified in Pseudopotential Data
    r = upfdata.r
    r_ab = upfdata.r_ab

    # Setting constants and aliases
    cellvol = grho.reallat_cellvol
    _4pibv = 4 * np.pi / cellvol
    _1bv = 1 / cellvol

    g_cryst = grho.cryst
    g_norm2 = grho.norm2
    g_norm = np.sqrt(g_norm2)

    valence = upfdata.z_valence

    struct_fac = np.sum(
        np.exp((-2 * np.pi * 1j) * (sp.cryst.T @ g_cryst)), axis=0
    )

    vloc = upfdata.vloc
    if upfdata.core_correction:
        rho_atc = upfdata.rho_atc
    else:
        rho_atc = None

    v_ion = GField.empty(grho, 1)
    rho_core = GField.empty(grho, 1)

    f_times_r2 = np.empty((1 + upfdata.core_correction, len(r)), dtype='f8')
    f_times_r2[0] = (vloc * r + valence * erf(r)) * r

    if upfdata.core_correction:
        f_times_r2[1] = rho_atc * r**2

    f_g = _sph2pw(r, r_ab, f_times_r2, g_norm[1:])

    v_ion.g[0, 0] = _simpson(r * (r * vloc + valence), r_ab)
    v_ion.g[0, 1:] = f_g[0] \
        - valence * np.exp(-g_norm2[1:] / 4) / g_norm2[1:]

    if upfdata.core_correction:
        rho_core.g[0, 0] = _simpson(rho_atc * r**2, r_ab)
        rho_core.g[0, 1:] = f_g[1]
    else:
        rho_core.g[:] = 0

    N = np.prod(grho.grid_shape)
    v_ion.g[:] *= _4pibv * N * struct_fac
    rho_core.g[:] *= _4pibv * N * struct_fac

    return v_ion, rho_core
