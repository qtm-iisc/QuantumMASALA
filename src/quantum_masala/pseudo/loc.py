__all__ = ["loc_generate", "rho_generate_atomic"]

import numpy as np
from scipy.special import erf, spherical_jn

from quantum_masala import pw_logger
from quantum_masala.core import AtomBasis, GSpace, GField
from .upf import UPFv2Data

EPS6 = 1e-6
BLOCK_SIZE = 20


def _simpson(f_r: np.ndarray, r_ab: np.ndarray):
    r12 = 1. / 3
    f_times_dr = f_r * r_ab
    # NOTE: Number of radial points specified in UPF File is expected to be odd. Will fail otherwise
    if f_r.ndim == 1:
        return r12 * np.sum(
            f_times_dr[0:-2:2] + 4 * f_times_dr[1:-1:2] + f_times_dr[2::2]
        )
    else:
        return r12 * np.sum(
            f_times_dr[..., 0:-2:2]
            + 4 * f_times_dr[..., 1:-1:2]
            + f_times_dr[..., 2::2],
            axis=1
        )


def _sph2pw(r: np.ndarray, r_ab: np.ndarray, f_times_r2: np.ndarray,
            g: np.ndarray):
    numg = g.shape[0]
    f_g = np.empty((*f_times_r2.shape[:-1], numg), dtype='c16')
    numr = r.shape[0]

    r_ab = r_ab.copy()
    r_ab *= 1./3
    r_ab[1:-1:2] *= 4
    r_ab[2:-1:2] *= 2
    f_g[:] = spherical_jn(0, g * r[0]) * f_times_r2[..., 0] * r_ab[0]

    g = g.reshape(-1, 1)
    f_times_r2 = np.expand_dims(f_times_r2, axis=-2)
    for idxr in range(0, numr, BLOCK_SIZE):
        f_g[:] += np.sum(spherical_jn(0, g * r[idxr:idxr+BLOCK_SIZE])
                         * f_times_r2[..., idxr:idxr + BLOCK_SIZE]
                         * r_ab[idxr:idxr + BLOCK_SIZE],
                        axis=-1)
    return f_g


@pw_logger.time('rho_generate_atomic')
def rho_generate_atomic(sp: AtomBasis, grho: GSpace):
    if sp.ppdata is None:
        raise ValueError("'sp.ppdata' must not be None.")
    if not isinstance(sp.ppdata, UPFv2Data):
        raise NotImplementedError("only 'UPFv2Data' supported")

    upfdata: UPFv2Data = sp.ppdata
    # Radial Mesh specified in Pseudopotential Data
    r = upfdata.r
    r_ab = upfdata.r_ab

    # Setting constants
    cellvol = grho.reallat_cellvol
    _4pibv = 4 * np.pi / cellvol
    _1bv = 1 / cellvol

    numg = grho.numg
    g_cryst = grho.cryst
    g_norm2 = grho.norm2
    g_norm = np.sqrt(g_norm2)

    struct_fac = np.sum(
        np.exp((-2 * np.pi * 1j) * (sp.cryst.T @ g_cryst)), axis=0
    )

    rhoatom = upfdata.rhoatom

    rho = GField.empty(grho, 1)

    f_times_r2 = np.empty((1, len(r)), dtype='f8')
    f_times_r2[0] = _1bv * rhoatom

    f_g = _sph2pw(r, r_ab, f_times_r2, g_norm[1:])
    rho.g[0, 0] = _1bv * _simpson(rhoatom, r_ab)
    rho.g[0, 1:] = f_g

    N = np.prod(grho.grid_shape)
    rho.g[:] *= N * struct_fac

    return rho


@pw_logger.time('loc_generate')
def loc_generate(sp: AtomBasis, grho: GSpace):
    """Computes the local term and electron densities generated by input atoms
    from pseudopotential data

    Parameters
    ----------
    sp : AtomBasis
        Group of atoms of the same type in unit cell. Must contain
        pseudopotential data
    grho : GSpace
        G-Space of the potential/charge density

    Returns
    -------
    v_loc : GField
        Local part of the pseudopotenital
    """
    if sp.ppdata is None:
        raise ValueError("'sp.ppdata' must not be None.")
    if not isinstance(sp.ppdata, UPFv2Data):
        raise NotImplementedError("only 'UPFv2Data' supported")

    upfdata: UPFv2Data = sp.ppdata
    # Radial Mesh specified in Pseudopotential Data
    r = upfdata.r
    r_ab = upfdata.r_ab

    # Setting constants
    cellvol = grho.reallat_cellvol
    _4pibv = 4 * np.pi / cellvol
    _1bv = 1 / cellvol

    numg = grho.numg
    g_cryst = grho.cryst
    g_norm2 = grho.norm2
    g_norm = np.sqrt(g_norm2)

    valence = upfdata.z_valence

    struct_fac = np.sum(
        np.exp((-2 * np.pi * 1j) * (sp.cryst.T @ g_cryst)), axis=0
    )

    vloc = upfdata.vloc
    if upfdata.core_correction:
        rho_atc = upfdata.rho_atc
    else:
        rho_atc = None

    v_ion = GField.empty(grho, 1)
    rho_core = GField.empty(grho, 1)

    f_times_r2 = np.empty((1 + upfdata.core_correction, len(r)), dtype='f8')
    f_times_r2[0] = (vloc * r + valence * erf(r)) * r

    if upfdata.core_correction:
        f_times_r2[1] = rho_atc * r**2

    f_g = _sph2pw(r, r_ab, f_times_r2, g_norm[1:])

    v_ion.g[0, 0] = _simpson(r * (r * vloc + valence), r_ab)
    v_ion.g[0, 1:] = f_g[0] \
        - valence * np.exp(-g_norm2[1:] / 4) / g_norm2[1:]

    if upfdata.core_correction:
        rho_core.g[0, 0] = _simpson(rho_atc * r**2, r_ab)
        rho_core.g[0, 1:] = f_g[1]
    else:
        rho_core.g[:] = 0

    N = np.prod(grho.grid_shape)
    v_ion.g[:] *= _4pibv * N * struct_fac
    rho_core.g[:] *= _4pibv * N * struct_fac

    return v_ion, rho_core
