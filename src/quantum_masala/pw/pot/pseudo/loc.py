import numpy as np
from scipy.special import erf, spherical_jn

from quantum_masala.core import AtomBasis, GSpace
from quantum_masala.core.ppdata import UPFv2Data

EPS6 = 1e-6


class PPDataLocal:
    """Class representing the local (pseudo)potential generated by all atoms of given species in crystal

    Attributes
    ----------
    species : AtomicSpecies
        Atomic species in the Unit Cell
    grho : GSpace
        `GSpace` object representing the local potential space (hard grid)
    numatoms : int
        Number of atoms of type `species` per unit cell
    numel : int
        Total number of valence electrons per unit cell given by type `species`
    struct_fac : int
        Structure Factor

    vlocal_g : np.ndarray
        Local Pseudo-potential by all atoms of type `species` in truncated fourier space `grho`
    rhoatomic_g : np.ndarray
        Atomic (pseudo-)charge by all atoms of type `species` in truncated fourier space `grho`
    rhocore_g : np.ndarray
        Atomic Core charge by all atoms of type `species` in truncated fourier space `grho`
    """

    species: AtomBasis
    grho: GSpace
    numatoms: int
    numel: float
    struct_fac: np.ndarray
    vlocal_g: np.ndarray
    rhoatomic_g: np.ndarray
    rhocore_g: np.ndarray

    def __init__(self, sp: AtomBasis, grho: GSpace):
        # Setting up
        self.species = sp
        if not isinstance(self.species.ppdata, UPFv2Data):
            raise NotImplementedError("only 'UPFv2Data' supported")
        upfdata: UPFv2Data = self.species.ppdata
        r = upfdata.r
        r_ab = upfdata.r_ab

        cellvol = self.species.reallat.cellvol
        _4pibv = 4 * np.pi / cellvol
        _1bv = 1 / cellvol

        self.grho = grho
        numg = self.grho.numg
        g_cryst = self.grho.cryst
        g_norm2 = self.grho.norm2
        g_norm = np.sqrt(g_norm2)

        valence = upfdata.z_valence
        self.numatoms = sp.numatoms
        self.numel = valence * self.numatoms

        print(sp.cryst.shape, g_cryst.shape)
        self.struct_fac = np.sum(
            np.exp((-2 * np.pi * 1j) * (sp.cryst.T @ g_cryst)), axis=0
        )

        # Defining Function for Simpsons' Integration
        def simpson(f_r: np.ndarray):
            r12 = 1 / 3
            f_times_dr = f_r * r_ab
            # NOTE: Number of radial points specified in UPF File is expected to be odd. Will fail otherwise
            return r12 * np.sum(
                f_times_dr[0:-2:2] + 4 * f_times_dr[1:-1:2] + f_times_dr[2::2]
            )

        self.vlocal_g = np.empty(numg, dtype="c16")
        self.rhoatomic_g = np.empty(numg, dtype="c16")
        self.rhocore_g = np.zeros(numg, dtype="c16")

        # Computing :math:`erf(r)/r`
        erf_by_r = np.divide(erf(r), r, where=(r > EPS6))
        erf_by_r[r < EPS6] = 2 / np.pi

        # Computing :math:`V_loc(\mathbf{G})`, :math:`\rho_at(\mathbf{G})`
        vloc = upfdata.vloc
        rhoatom = upfdata.rhoatom
        if upfdata.core_correction:
            rho_atc = upfdata.rho_atc
        else:
            rho_atc = None

        # For :math`\mathbf{G} = 0`
        self.vlocal_g[0] = _4pibv * simpson((1 * r) * (r * vloc + valence))
        self.rhoatomic_g[0] = _1bv * simpson(rhoatom)

        vloc_short = vloc + valence * erf_by_r
        for idxg in range(1, numg):  # For `\mathbf{G} \neq 0`
            g, g2 = g_norm[idxg], g_norm2[idxg]
            sph_j0_gr = spherical_jn(0, g * r)

            self.vlocal_g[idxg] = _4pibv * (
                simpson(sph_j0_gr * r**2 * vloc_short)
                - valence * np.exp(-g2 / 4) / g2
            )
            self.rhoatomic_g[idxg] = _1bv * simpson(sph_j0_gr * rhoatom)

            if upfdata.core_correction:
                self.rhocore_g[idxg] = _4pibv * simpson(sph_j0_gr * r**2 * rho_atc)

        N = np.prod(self.grho.grid_shape)
        self.vlocal_g *= N * self.struct_fac
        self.rhoatomic_g *= N * self.struct_fac
        self.rhocore_g *= N * self.struct_fac
